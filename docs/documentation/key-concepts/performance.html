<!DOCTYPE html>
<html lang="en">
  
  <head>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="generator" content="Typelevel Laika + Helium Theme" />
  <title>Performance</title>
  
  
  <meta name="description" content="An FP game engine for Scala."/>
  
  
  
  <link rel="icon" sizes="32x32" type="image/png" href="../../img/favicon.png"/>
  
  
  <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Lato:400,700">
  
  <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Fira+Mono:500">
  
  <link rel="stylesheet" type="text/css" href="../../helium/site/icofont.min.css" />
    <link rel="stylesheet" type="text/css" href="../../helium/site/laika-helium.css" />
    <link rel="stylesheet" type="text/css" href="../../css/custom.css" />
  <script src="../../helium/site/laika-helium.js"></script>
  
  
  <script> /* for avoiding page load transitions */ </script>
</head>

  <body>

    <header id="top-bar" class="light-default dark-default">

  <div class="row">
    <a id="nav-icon">
      <i class="icofont-laika navigationMenu" title="Navigation">&#xefa2;</i>
    </a>
    
    
  </div>

  <a class="image-link" href="../"><img src="../../img/indigo_logo_solid_text.svg" alt="An FP game engine for Scala." title="Indigo" width="150" height="50"></a>

  <div class="row links">
    
    <a class="button-link" href="https://purplekingdomgames.github.io/indigo-docs/live_demos">Live Demos</a>
    
    <a class="button-link" href="https://discord.gg/b5CD47g">Discord</a>
    
    <a class="button-link" href="https://github.com/PurpleKingdomGames/indigo">Github</a>
    
  </div>  

</header>
    
    <nav id="sidebar">

  <div class="row">
    
    <a class="button-link" href="https://purplekingdomgames.github.io/indigo-docs/live_demos">Live Demos</a>
    
    <a class="button-link" href="https://discord.gg/b5CD47g">Discord</a>
    
    <a class="button-link" href="https://github.com/PurpleKingdomGames/indigo">Github</a>
    
  </div>

  <ul class="nav-list">
    <li class="level1 nav-node"><a href="../">Indigo</a></li>
    <li class="level2 nav-header">Indigo</li>
    <li class="level3 nav-leaf"><a href="model-viewmodel-view.html">Model, ViewModel, &amp; View</a></li>
    <li class="level3 nav-leaf"><a href="time.html">Time</a></li>
    <li class="level3 active nav-leaf"><a href="#">Performance</a></li>
    <li class="level3 nav-leaf"><a href="making-games-testable.html">Making games testable</a></li>
    <li class="level2 nav-header">Shaders</li>
    <li class="level3 nav-leaf"><a href="../shaders/shaders.html">Shaders</a></li>
    <li class="level2 nav-header">Quick start</li>
    <li class="level3 nav-leaf"><a href="../quickstart/extensions-and-libs.html">Extensions, Libraries, and Related Projects</a></li>
    <li class="level3 nav-leaf"><a href="../quickstart/quickstart.html">Quick start</a></li>
    <li class="level3 nav-leaf"><a href="../quickstart/examples.html">Examples, Demos, and References</a></li>
    <li class="level2 nav-header">General information</li>
    <li class="level3 nav-leaf"><a href="../misc/prior-art.html">Prior Art</a></li>
    <li class="level3 nav-leaf"><a href="../misc/motivation-and-constraints.html">Motivation &amp; Constraints</a></li>
    <li class="level3 nav-leaf"><a href="../misc/rendering-technology.html">Rendering Technology</a></li>
    <li class="level3 nav-leaf"><a href="../misc/indigo-vs-elm.html">Indigo vs Elm</a></li>
    <li class="level1 nav-node"><a href="../../demos/">Demos</a></li>
    <li class="level2 nav-leaf"><a href="../../demos/snake/">Snake!</a></li>
    <li class="level2 nav-leaf"><a href="../../demos/snake-in-5-minutes/">Snake In 5 Minutes</a></li>
    <li class="level2 nav-leaf"><a href="../../demos/the-cursed-pirate/">The Cursed Pirate!</a></li>
    <li class="level1 nav-node"><a href="../../guides/">Guides</a></li>
    <li class="level2 nav-node"><a href="../../guides/actors/">Actors</a></li>
    <li class="level3 nav-leaf"><a href="../../guides/actors/actors-with-physics/">How to use physics with actors</a></li>
    <li class="level2 nav-node"><a href="../../guides/animation/">Animation</a></li>
    <li class="level3 nav-leaf"><a href="../../guides/animation/part-1-basics/">Part 1: Animation Fundamentals</a></li>
    <li class="level3 nav-leaf"><a href="../../guides/animation/part-2-signals/">Part 2: Using Signals</a></li>
    <li class="level3 nav-leaf"><a href="../../guides/animation/part-3-timelines/">Part 3: Timeline Animations</a></li>
    <li class="level3 nav-leaf"><a href="../../guides/animation/part-4-shaders/">Part 4: Shader Animations</a></li>
    <li class="level2 nav-node"><a href="../../guides/assets/">Assets</a></li>
    <li class="level3 nav-leaf"><a href="../../guides/assets/preloader/">Preloader / Loading Screens</a></li>
    <li class="level2 nav-node"><a href="../../guides/importers/">Importers</a></li>
    <li class="level3 nav-leaf"><a href="../../guides/importers/aseprite-embedded/">Aseprite Embedded</a></li>
    <li class="level3 nav-leaf"><a href="../../guides/importers/tiled-loaded/">Loading Tiled maps at runtime</a></li>
    <li class="level2 nav-node"><a href="../../guides/scenes/">Scenes</a></li>
    <li class="level3 nav-leaf"><a href="../../guides/scenes/scene-management/">Managing scenes</a></li>
    <li class="level2 nav-node"><a href="../../guides/ui/">Ui</a></li>
    <li class="level3 nav-leaf"><a href="../../guides/ui/radiobuttons/">How to make radio buttons</a></li>
    <li class="level1 nav-node"><a href="../../features/">Features</a></li>
    <li class="level2 nav-node"><a href="../../features/actors-and-performers/">Actors and performers</a></li>
    <li class="level3 nav-leaf"><a href="../../features/actors-and-performers/actors/">Actors</a></li>
    <li class="level3 nav-leaf"><a href="../../features/actors-and-performers/performers/">Performers</a></li>
    <li class="level3 nav-leaf"><a href="../../features/actors-and-performers/performers-with-physics/">Performers &amp; Physics</a></li>
    <li class="level2 nav-leaf"><a href="../../features/context/">Context</a></li>
    <li class="level2 nav-node"><a href="../../features/materials/">Materials</a></li>
    <li class="level3 nav-leaf"><a href="../../features/materials/bitmap/">Bitmap material</a></li>
    <li class="level3 nav-leaf"><a href="../../features/materials/filltypes/">Fill Types</a></li>
    <li class="level3 nav-leaf"><a href="../../features/materials/imageeffects/">ImageEffects material</a></li>
    <li class="level2 nav-node"><a href="../../features/physics/">Physics</a></li>
    <li class="level3 nav-leaf"><a href="../../features/physics/basics/">Basic Physics Example</a></li>
    <li class="level2 nav-node"><a href="../../features/primitives/">Primitives</a></li>
    <li class="level3 nav-leaf"><a href="../../features/primitives/blank/">Blank Entity</a></li>
    <li class="level3 nav-leaf"><a href="../../features/primitives/clip/">Clip</a></li>
    <li class="level3 nav-leaf"><a href="../../features/primitives/graphic/">Graphic</a></li>
    <li class="level3 nav-leaf"><a href="../../features/primitives/group/">Group</a></li>
    <li class="level3 nav-node"><a href="../../features/primitives/shapes/">Shapes</a></li>
    <li class="level4 nav-leaf"><a href="../../features/primitives/shapes/box/">Shape.Box</a></li>
    <li class="level4 nav-leaf"><a href="../../features/primitives/shapes/circle/">Shape.Circle</a></li>
    <li class="level4 nav-leaf"><a href="../../features/primitives/shapes/line/">Shape.Line</a></li>
    <li class="level4 nav-leaf"><a href="../../features/primitives/shapes/polygon/">Shape.Polygon</a></li>
    <li class="level3 nav-leaf"><a href="../../features/primitives/sprite/">Sprite</a></li>
    <li class="level3 nav-leaf"><a href="../../features/primitives/text/">Text</a></li>
    <li class="level2 nav-node"><a href="../../features/scenes/">Scenes</a></li>
    <li class="level3 nav-leaf"><a href="../../features/scenes/minimal/">Minimal scene example</a></li>
    <li class="level2 nav-node"><a href="../../features/shaders/">Shaders</a></li>
    <li class="level3 nav-leaf"><a href="../../features/shaders/basic/">A basic custom shader</a></li>
    <li class="level2 nav-node"><a href="../../features/time/">Time</a></li>
    <li class="level3 nav-leaf"><a href="../../features/time/signals/">Signals &amp; Signal Functions</a></li>
    <li class="level3 nav-leaf"><a href="../../features/time/time-varying-values/">Time Varying Values</a></li>
    <li class="level2 nav-node"><a href="../../features/ui/">Ui</a></li>
    <li class="level3 nav-leaf"><a href="../../features/ui/button/">UI Components: Button</a></li>
    <li class="level3 nav-leaf"><a href="../../features/ui/component-group/">UI Components: Component Group</a></li>
    <li class="level3 nav-leaf"><a href="../../features/ui/component-list/">UI Components: Component List</a></li>
    <li class="level3 nav-leaf"><a href="../../features/ui/custom/">UI Components: Custom Components</a></li>
    <li class="level3 nav-leaf"><a href="../../features/ui/hitarea/">UI Components: HitArea</a></li>
    <li class="level3 nav-leaf"><a href="../../features/ui/input/">UI Components: Input</a></li>
    <li class="level3 nav-leaf"><a href="../../features/ui/label/">UI Components: Label</a></li>
    <li class="level3 nav-leaf"><a href="../../features/ui/maskedpane/">UI Components: Masked Pane</a></li>
    <li class="level3 nav-leaf"><a href="../../features/ui/scrollpane/">UI Components: Scroll Pane</a></li>
    <li class="level3 nav-leaf"><a href="../../features/ui/switch/">UI Components: Switch</a></li>
    <li class="level3 nav-leaf"><a href="../../features/ui/textarea/">UI Components: TextArea</a></li>
    <li class="level3 nav-leaf"><a href="../../features/ui/window/">UI Components: Windows</a></li>
  </ul>

</nav>

    <div id="container">

      
<nav id="page-nav">
  <p class="header"><a href="#">Performance</a></p>

  <ul class="nav-list">
    <li class="level1 nav-leaf"><a href="#what-is-performance">What is performance?</a></li>
    <li class="level1 nav-node"><a href="#is-it-fast-enough">Is it fast enough?</a></li>
    <li class="level2 nav-leaf"><a href="#start-on-the-assumption-that-it-will-be-fast-enough">Start on the assumption that it will be fast enough</a></li>
    <li class="level2 nav-leaf"><a href="#one-weird-trick-to-grind-indigo-to-a-halt">One weird trick to grind Indigo to a halt</a></li>
    <li class="level1 nav-node"><a href="#performance-tips-how-to-get-more-speed">Performance Tips: How to get more speed</a></li>
    <li class="level2 nav-leaf"><a href="#measure-twice-cut-once">Measure twice, cut once</a></li>
    <li class="level2 nav-leaf"><a href="#if-you-can-t-see-it-don-t-draw-it">If you can&#39;t see it, don&#39;t draw it</a></li>
    <li class="level2 nav-leaf"><a href="#render-batch-size">Render batch size</a></li>
    <li class="level2 nav-leaf"><a href="#use-clones-clonetiles-and-mutants">Use Clones, CloneTiles, and Mutants</a></li>
    <li class="level2 nav-leaf"><a href="#cache-values">Cache values</a></li>
    <li class="level2 nav-leaf"><a href="#faster-processing">Faster processing</a></li>
    <li class="level2 nav-leaf"><a href="#use-batch-not-list">Use <code>Batch</code>, not <code>List</code></a></li>
    <li class="level1 nav-leaf"><a href="#don-t-fear-mutability">Don&#39;t fear mutability</a></li>
  </ul>

  <p class="footer"></p>
</nav>


      <main class="content">

        <h1 id="performance" class="title">Performance</h1>
        
        <h2 id="what-is-performance" class="section"><a class="anchor-link left" href="#what-is-performance"><i class="icofont-laika link">&#xef71;</i></a>What is performance?</h2>
        <p><strong>Lets get one thing clear:</strong> Indigo is not the fastest 2D game engine out there. It might even be the slowest - who knows! Nonetheless, it is definitely <em>fast enough</em>, and games programmed well can expect to run at 60 frames per second.</p>
        <p>Performance is relative. When people talk about game engine performance, they are usually talking about how many things it can do at once.</p>
        <p>The way raw engine performance is typically achieved is by utilizing clever data structures, mutable data stores, reusing allocated memory to keep usage constant, insisting on never creating new objects, and utilizing multi-threading.</p>
        <p>All of that <em>can</em> lead to higher performance, but it takes careful management since your guarantees around runtime behavior are reduced, and bugs can occur.</p>
        <p>In order to bring performance up, Indigo itself does all this too. Where Indigo and normal game engines diverge is that while these techniques are used by Indigo under the covers, it is strongly discouraged at the API level. Why is that?</p>
        <p>What if you could build games with an expectation of no bugs? Games that you <em>know</em> work before you play them because you can bring to bear an advanced type system, property based testing, TDD (without excessive mocking), and any other code quality tool you can think of?</p>
        <p>Couldn&#39;t developer productivity be considered a type of performance too? The design aim of Indigo is to take an engine performance hit at the API level, in order to increase developer performance (easy to reason about, easy to test) and game production efficiency.</p>
        <p><em>Please note: You&#39;re still going to have to play your game at some point. No automated test suite in the world will tell you if you&#39;ve made something fun or not!</em></p>
        
        <h2 id="is-it-fast-enough" class="section"><a class="anchor-link left" href="#is-it-fast-enough"><i class="icofont-laika link">&#xef71;</i></a>Is it fast enough?</h2>
        <p><em>TL;DR: Yes, but...</em></p>
        <p>Two slightly disappointing observations that we&#39;ve made about 2D games during Indigo&#39;s development:</p>
        <ol class="arabic">
          <li>Most 2D games on the market don&#39;t actually have that many elements on screen at any one time - there&#39;s only so much screen real estate available for use when you have no real perspective or depth. (Naturally there are exceptions)</li>
          <li>Most game logic is quite straight forward, and revolves around a few core mechanics. The complexity is in how the elements interact.</li>
        </ol>
        <p>With that in mind then: Indigo is fast enough that you should not have to do anything clever or special to be able to hit a respectable frame rate for simple games.</p>
        <p>That said, some games and game developers always have and always will push what can be done by the system and engine they run on to the edge of what is possible. If you do that with your game, you may need to roll up your sleeves and think of clever ways to solve problems efficiently, but that is a high quality problem to have.</p>
        
        <h3 id="start-on-the-assumption-that-it-will-be-fast-enough" class="section"><a class="anchor-link left" href="#start-on-the-assumption-that-it-will-be-fast-enough"><i class="icofont-laika link">&#xef71;</i></a>Start on the assumption that it will be fast enough</h3>
        <p>In general, you should start by assuming Indigo will be fast enough. Build your game using good functional programming practices, and write your tests.</p>
        <p>You should only consider changing things if it really isn&#39;t fast enough when you play / performance test it. Remember that it&#39;s always easier to make clean, well written code go faster, than trying to improve the performance of something messy.</p>
        
        <h3 id="one-weird-trick-to-grind-indigo-to-a-halt" class="section"><a class="anchor-link left" href="#one-weird-trick-to-grind-indigo-to-a-halt"><i class="icofont-laika link">&#xef71;</i></a>One weird trick to grind Indigo to a halt</h3>
        <p>Try and render 1000 standard primitives of any type, better yet, put each one on its own layer. Performance will be bad!</p>
        <p>Is 1000 a lot? It depends on what you&#39;re trying to render. If you want to render a standard roguelike map of 80x50 tiles - which is 4000 tiles - then it&#39;s not nearly enough! If you&#39;re rendering a little platformer then 1000 is probably ample.</p>
        <p>The problem is not the requirement, it&#39;s the approach. Naively rendering 1000 things will make performance suffer, but choosing a different data structure or rendering primitive, such as clones, will allow you to put more things on the screen.</p>
        
        <h2 id="performance-tips-how-to-get-more-speed" class="section"><a class="anchor-link left" href="#performance-tips-how-to-get-more-speed"><i class="icofont-laika link">&#xef71;</i></a>Performance Tips: How to get more speed</h2>
        <p>Depending on what kind of thing you&#39;re doing, you can make Indigo do more in less time.</p>
        <p>Indigo is single threaded and runs in the browser. JavaScript code execution these days is very fast, and your game logic draining CPU power is probably not a concern, nor is available memory.</p>
        <p><strong>Your main enemy in the quest for performance is memory allocation and the subsequent garbage collection pauses.</strong></p>
        <p>The near universal mantra of game developers is to never allocate memory, i.e. create new objects, during a frame. Ever. <strong>Reuse, reuse, reuse.</strong></p>
        <p>Unfortunately, Indigo is built on Scala offering up an immutable API, so we&#39;re going to be making new objects <em>all the time</em>.</p>
        <p>Generally your performance will suffer the more things you add to the screen. Our goal is to get the same effect you get by adding lots of things, but by doing less work. Here are a few tips for squeezing out some extra juice.</p>
        
        <h3 id="measure-twice-cut-once" class="section"><a class="anchor-link left" href="#measure-twice-cut-once"><i class="icofont-laika link">&#xef71;</i></a>Measure twice, cut once</h3>
        <blockquote>Be Aware: Running profiling tooling is, itself, expensive! You&#39;re game might do 58 FPS normally and 47 under profiling. Try plugging in the FPS Counter <code>SubSystem</code> for another view, or finding your browsers built in FPS viewer if it has one.</blockquote>
        <p>Modern browsers have amazing profiling tools built into them these days. Get to know them by recording the performance of your running game, and then look for evidence of where you&#39;re creating things like GC pauses or large numbers of allocations, and try to track down the culprit code.</p>
        <p>If you aren&#39;t improving the slowest bottleneck of your game code, you aren&#39;t improving anything.</p>
        
        <h3 id="if-you-can-t-see-it-don-t-draw-it" class="section"><a class="anchor-link left" href="#if-you-can-t-see-it-don-t-draw-it"><i class="icofont-laika link">&#xef71;</i></a>If you can&#39;t see it, don&#39;t draw it</h3>
        <p>Normally when you create a game element like a sprite in a conventional game engine, they hang around until you remove them. Indigo only draws what your <code>SceneUpdateFragment</code> describes <strong>as a result of the <code>present</code> function</strong>, nothing hangs around between frames. As such, Indigo assumes you know what you&#39;re doing and doesn&#39;t try to do any clever interpretation of your scene.</p>
        
        <h3 id="render-batch-size" class="section"><a class="anchor-link left" href="#render-batch-size"><i class="icofont-laika link">&#xef71;</i></a>Render batch size</h3>
        <blockquote>WebGL 2.0 only!</blockquote>
        <p>There is a batch size option in the main game config that you can tweak, it relates to the maximum number of renderable items that are bundled up before a draw call is issued. It&#39;s a trade off: Bigger batches mean more memory usage but fewer calls to the graphics card.</p>
        <p>In general, fiddling with this value will only affect games with a lot of scene elements.</p>
        
        <h3 id="use-clones-clonetiles-and-mutants" class="section"><a class="anchor-link left" href="#use-clones-clonetiles-and-mutants"><i class="icofont-laika link">&#xef71;</i></a>Use Clones, CloneTiles, and Mutants</h3>
        <blockquote>WebGL 2.0 only!</blockquote>
        <p><code>Clones</code>, <code>CloneTiles</code> and <code>Mutants</code> are Indigo&#39;s version of what is known as &quot;instancing&quot;. Say you want to render lots (lots and lots and lots!) of things that are more or less identical, such as blades of grass or tiles in a tile map, you should consider using one of these types instead of normal primitives.</p>
        
        <h3 id="cache-values" class="section"><a class="anchor-link left" href="#cache-values"><i class="icofont-laika link">&#xef71;</i></a>Cache values</h3>
        <p>May seem obvious but some values are just expensive to work out. Object boundaries for example, particularly text boundaries or groups with many elements, can be quite expensive to calculate. If you (as the game programmer) know that a value is going to be used a lot but is never going to need to be recalculated, consider storing it and looking it up next time. In the example of boundaries, a good place to store it might be as part of the view model.</p>
        
        <h4 id="reuse-animations" class="section"><a class="anchor-link left" href="#reuse-animations"><i class="icofont-laika link">&#xef71;</i></a>Reuse animations</h4>
        <p>One way to reduce the cost of animated elements is to reuse them!</p>
        <p><strong>Example scenario:</strong> You have a number of background elements, and it&#39;s acceptable for all of them to be on the same animation loop at the exact same frame position (e.g. you have a forest and 25% of the trees are identical), but you want to be able to interact with them individually (thus ruling out clones).</p>
        <ol class="arabic">
          <li>Establish a master sprite;</li>
          <li>Give all of the sprites the same animation key;</li>
          <li>Only update the animation of the master sprite;</li>
          <li>All the others will be animated identically but with no additional event or animation processing cost.</li>
        </ol>
        
        <h4 id="animate-with-clips" class="section"><a class="anchor-link left" href="#animate-with-clips"><i class="icofont-laika link">&#xef71;</i></a>Animate with Clips</h4>
        <p>If possible, swap Sprites for Clips which are much cheaper to run.</p>
        
        <h3 id="faster-processing" class="section"><a class="anchor-link left" href="#faster-processing"><i class="icofont-laika link">&#xef71;</i></a>Faster processing</h3>
        <p>In terms of view processing, memory allocations are typically the problem, but you can also experience CPU bottlenecks depending on the kind of game you&#39;re building.</p>
        
        <h4 id="use-appropriate-data-structures" class="section"><a class="anchor-link left" href="#use-appropriate-data-structures"><i class="icofont-laika link">&#xef71;</i></a>Use appropriate data structures</h4>
        <p>In many cases, a simple array of things to process will do. However, just as an example, if you&#39;re processing something spacial like collision detection or available moves on large playing grid, you should look for data structures that can efficiently ignore / avoid processing irrelevant areas, such as a <a href="https://en.wikipedia.org/wiki/Binary_space_partitioning">BSP</a> or <a href="https://en.wikipedia.org/wiki/Quadtree">Quadtree</a> structures.</p>
        
        <h3 id="use-batch-not-list" class="section"><a class="anchor-link left" href="#use-batch-not-list"><i class="icofont-laika link">&#xef71;</i></a>Use <code>Batch</code>, not <code>List</code></h3>
        <p><code>List</code> in Scala.js is very slow compared to native JavaScript arrays, i.e. <code>js.Array</code>. <code>Batch</code> is a wrapper around <code>js.Array</code> that mimics some <code>List</code>-like functionality and also provides very fast concatenation, which is something we do a lot of in Indigo.</p>
        
        <h4 id="use-updatelist" class="section"><a class="anchor-link left" href="#use-updatelist"><i class="icofont-laika link">&#xef71;</i></a>Use <code>UpdateList</code></h4>
        <p>Split expensive calculation work over multiple frames.</p>
        <p><strong>Scenario:</strong></p>
        <p>You&#39;re writing a farming game and have a massive grid of crops to update. You can certainly reduce the drawing overhead using some of the techniques previously mentioned, but what about updating them all?</p>
        <p>To help with the time element, you could use a <code>TimeVaryingValue</code> that will automatically advance the value of the crops for a given time. But what if updating all the elements is expensive - perhaps your calculation has to decide what&#39;s happening to the crop based on many environmental conditions?</p>
        <p>If you wrap your crops up in an <code>UpdateList</code> you can specify an update pattern, for example you could update 25% of the crops this frame, and 25% on each of the next three subsequent frames until they&#39;re all done. As long as your calculation is time based, and the accuracy of when you need to know the crops are ready is acceptable to be within 4 frames of the actual completion time, you can quarter your per frame processing costs.</p>
        <p>Note that you&#39;re still allocating for the whole grid in this scenario! Consider combining these with better data structures as discussed above for further gains.</p>
        
        <h2 id="don-t-fear-mutability" class="section"><a class="anchor-link left" href="#don-t-fear-mutability"><i class="icofont-laika link">&#xef71;</i></a>Don&#39;t fear mutability</h2>
        <p>Your last angle of attack is to use mutable data and imperative programming techniques.</p>
        <p>Scala is an impure functional language and there is nothing wrong with taking advantage of that. You should always pull for purity and immutability first, but games by their very nature are always pushing the resource constraints of their system in one way or another, and finding game performance is about making trade-offs. <em>Sometimes</em> the trade off is your purely functional sensibilities!</p>
        <p>If you&#39;ve measured and identified an area of your code that is causing a bottleneck, <em>sometimes</em> the best solution is to roll up your sleeves and use a more imperative solution to do a bit of specific, localized, optimization. <strong><em>Never ever</em></strong> do this without profiling your code first, or you&#39;re probably wasting your time.</p>
        <p>Remember, a function is pure and referentially transparent as long as for a given set of arguments you always get the same result - there are no limits on how your implementation makes that happen. Using a while loop and a var is not against the rules! Just write good tests, and use strong encapsulation.</p>

        
<hr class="footer-rule"/>
<footer>
  Site generated by <a href="https://typelevel.org/Laika/">Laika</a> with the Helium theme.
</footer>


      </main>

    </div>

  </body>

</html>